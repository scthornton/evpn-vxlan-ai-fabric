#!/bin/bash
#
# deploy_base_config.sh - Automated EVPN-VxLAN Deployment Script
# Author: Scott Thornton
# Description: Deploys base configuration to all devices in the topology
#

set -e  # Exit on error

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Configuration
TOPOLOGY_FILE="${1:-configs/topology.json}"
SSH_USER="cumulus"
SSH_PASS="cumulus"
LOG_DIR="logs"
PARALLEL_JOBS=4

# Create log directory
mkdir -p "$LOG_DIR"

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_DIR/deployment.log"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" | tee -a "$LOG_DIR/deployment.log"
    exit 1
}

warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1" | tee -a "$LOG_DIR/deployment.log"
}

# Check prerequisites
check_prerequisites() {
    log "Checking prerequisites..."
    
    # Check for required commands
    for cmd in jq sshpass parallel; do
        if ! command -v $cmd &> /dev/null; then
            error "$cmd is required but not installed. Install it and try again."
        fi
    done
    
    # Check topology file exists
    if [ ! -f "$TOPOLOGY_FILE" ]; then
        error "Topology file not found: $TOPOLOGY_FILE"
    fi
    
    log "Prerequisites check passed"
}

# Parse topology file
parse_topology() {
    log "Parsing topology file..."
    
    # Extract devices
    SPINES=$(jq -r '.devices[] | select(.type == "spine") | .name' "$TOPOLOGY_FILE")
    LEAVES=$(jq -r '.devices[] | select(.type == "leaf") | .name' "$TOPOLOGY_FILE")
    HOSTS=$(jq -r '.hosts[].name' "$TOPOLOGY_FILE")
    
    log "Found $(echo $SPINES | wc -w) spines, $(echo $LEAVES | wc -w) leaves, $(echo $HOSTS | wc -w) hosts"
}

# Generate spine configuration
generate_spine_config() {
    local spine_name=$1
    local spine_data=$(jq -r ".devices[] | select(.name == \"$spine_name\")" "$TOPOLOGY_FILE")
    local asn=$(echo "$spine_data" | jq -r '.asn')
    local loopback=$(echo "$spine_data" | jq -r '.loopback_ip')
    
    cat > "$LOG_DIR/${spine_name}.conf" << EOF
# Configuration for $spine_name
# Generated by deploy_base_config.sh

# Hostname and basic settings
net add hostname $spine_name
net add time zone UTC

# Loopback interface
net add loopback lo ip address ${loopback}/32

# BGP Configuration
net add bgp autonomous-system $asn
net add bgp router-id $loopback

# Interface configuration will be added based on topology
EOF

    # Add interface configurations
    local interfaces=$(jq -r ".links[] | select(.source == \"$spine_name\") | .source_interface" "$TOPOLOGY_FILE")
    for intf in $interfaces; do
        local link=$(jq -r ".links[] | select(.source == \"$spine_name\" and .source_interface == \"$intf\")" "$TOPOLOGY_FILE")
        local dest=$(echo "$link" | jq -r '.destination')
        local dest_ip=$(echo "$link" | jq -r '.destination_ip')
        local src_ip=$(echo "$link" | jq -r '.source_ip')
        local dest_asn=$(jq -r ".devices[] | select(.name == \"$dest\") | .asn" "$TOPOLOGY_FILE")
        
        cat >> "$LOG_DIR/${spine_name}.conf" << EOF

# Interface $intf to $dest
net add interface $intf ip address $src_ip
net add bgp neighbor $dest_ip remote-as $dest_asn
EOF
    done
    
    # Add EVPN configuration
    cat >> "$LOG_DIR/${spine_name}.conf" << EOF

# EVPN Configuration
net add bgp ipv4 unicast network ${loopback}/32
EOF

    # Add leaf EVPN neighbors
    for leaf in $LEAVES; do
        local leaf_loopback=$(jq -r ".devices[] | select(.name == \"$leaf\") | .loopback_ip" "$TOPOLOGY_FILE")
        cat >> "$LOG_DIR/${spine_name}.conf" << EOF
net add bgp l2vpn evpn neighbor $leaf_loopback activate
EOF
    done
    
    echo "net commit" >> "$LOG_DIR/${spine_name}.conf"
}

# Generate leaf configuration
generate_leaf_config() {
    local leaf_name=$1
    local leaf_data=$(jq -r ".devices[] | select(.name == \"$leaf_name\")" "$TOPOLOGY_FILE")
    local asn=$(echo "$leaf_data" | jq -r '.asn')
    local loopback=$(echo "$leaf_data" | jq -r '.loopback_ip')
    
    cat > "$LOG_DIR/${leaf_name}.conf" << EOF
# Configuration for $leaf_name
# Generated by deploy_base_config.sh

# Hostname and basic settings
net add hostname $leaf_name
net add time zone UTC

# Loopback interface
net add loopback lo ip address ${loopback}/32

# BGP Configuration
net add bgp autonomous-system $asn
net add bgp router-id $loopback

# Bridge configuration
net add bridge bridge ports none
net add bridge bridge vlan-aware
EOF

    # Add spine-facing interfaces
    local interfaces=$(jq -r ".links[] | select(.source == \"$leaf_name\") | .source_interface" "$TOPOLOGY_FILE")
    for intf in $interfaces; do
        local link=$(jq -r ".links[] | select(.source == \"$leaf_name\" and .source_interface == \"$intf\")" "$TOPOLOGY_FILE")
        local dest=$(echo "$link" | jq -r '.destination')
        local dest_ip=$(echo "$link" | jq -r '.destination_ip')
        local src_ip=$(echo "$link" | jq -r '.source_ip')
        local dest_asn=$(jq -r ".devices[] | select(.name == \"$dest\") | .asn" "$TOPOLOGY_FILE")
        
        cat >> "$LOG_DIR/${leaf_name}.conf" << EOF

# Interface $intf to $dest
net add interface $intf ip address $src_ip
net add bgp neighbor $dest_ip remote-as $dest_asn
EOF
    done
    
    # Add EVPN configuration
    cat >> "$LOG_DIR/${leaf_name}.conf" << EOF

# EVPN Configuration
net add bgp ipv4 unicast network ${loopback}/32
net add bgp l2vpn evpn advertise-all-vni

# VxLAN Configuration
EOF

    # Add VNI configuration
    local vnis=$(jq -r ".vnis[] | select(.leaves[] | contains(\"$leaf_name\")) | .vni" "$TOPOLOGY_FILE" 2>/dev/null || echo "10 20")
    for vni in $vnis; do
        cat >> "$LOG_DIR/${leaf_name}.conf" << EOF
net add vxlan vni${vni} vxlan id ${vni}
net add vxlan vni${vni} vxlan local-tunnelip ${loopback}
net add vxlan vni${vni} bridge access ${vni}
net add bridge bridge ports vni${vni}
net add bridge bridge vids ${vni}
EOF
    done
    
    # Add host-facing interfaces
    cat >> "$LOG_DIR/${leaf_name}.conf" << EOF

# Host-facing interfaces
net add interface swp10 bridge access 10
net add bridge bridge ports swp10
EOF

    # Add spine EVPN neighbors
    for spine in $SPINES; do
        local spine_loopback=$(jq -r ".devices[] | select(.name == \"$spine\") | .loopback_ip" "$TOPOLOGY_FILE")
        cat >> "$LOG_DIR/${leaf_name}.conf" << EOF
net add bgp l2vpn evpn neighbor $spine_loopback activate
EOF
    done
    
    echo "net commit" >> "$LOG_DIR/${leaf_name}.conf"
}

# Deploy configuration to device
deploy_config() {
    local device_name=$1
    local device_ip=$(jq -r ".devices[] | select(.name == \"$device_name\") | .mgmt_ip" "$TOPOLOGY_FILE")
    local config_file="$LOG_DIR/${device_name}.conf"
    
    if [ ! -f "$config_file" ]; then
        error "Configuration file not found for $device_name"
    fi
    
    log "Deploying configuration to $device_name ($device_ip)..."
    
    # Copy configuration file
    sshpass -p "$SSH_PASS" scp -o StrictHostKeyChecking=no "$config_file" "$SSH_USER@$device_ip:/tmp/" 2>/dev/null || {
        error "Failed to copy configuration to $device_name"
    }
    
    # Apply configuration
    sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no "$SSH_USER@$device_ip" \
        "sudo net clear config force; sudo net add config file /tmp/${device_name}.conf" 2>/dev/null || {
        error "Failed to apply configuration on $device_name"
    }
    
    log "Configuration deployed successfully to $device_name"
}

# Verify device configuration
verify_device() {
    local device_name=$1
    local device_ip=$(jq -r ".devices[] | select(.name == \"$device_name\") | .mgmt_ip" "$TOPOLOGY_FILE")
    
    log "Verifying $device_name..."
    
    # Check BGP status
    local bgp_status=$(sshpass -p "$SSH_PASS" ssh -o StrictHostKeyChecking=no "$SSH_USER@$device_ip" \
        "net show bgp summary json" 2>/dev/null)
    
    if [ $? -eq 0 ]; then
        local peers_up=$(echo "$bgp_status" | jq '[.peers[].state | select(. == "Established")] | length')
        local total_peers=$(echo "$bgp_status" | jq '.peers | length')
        
        if [ "$peers_up" -eq "$total_peers" ] && [ "$total_peers" -gt 0 ]; then
            log "$device_name: All BGP peers up ($peers_up/$total_peers)"
        else
            warning "$device_name: Only $peers_up/$total_peers BGP peers up"
        fi
    else
        warning "Could not verify $device_name"
    fi
}

# Main deployment function
main() {
    log "Starting EVPN-VxLAN deployment..."
    
    # Check prerequisites
    check_prerequisites
    
    # Parse topology
    parse_topology
    
    # Generate configurations
    log "Generating configurations..."
    
    for spine in $SPINES; do
        generate_spine_config "$spine"
    done
    
    for leaf in $LEAVES; do
        generate_leaf_config "$leaf"
    done
    
    # Deploy configurations in parallel
    log "Deploying configurations..."
    
    export -f deploy_config error log
    export TOPOLOGY_FILE SSH_USER SSH_PASS LOG_DIR
    
    echo $SPINES $LEAVES | tr ' ' '\n' | parallel -j $PARALLEL_JOBS deploy_config {}
    
    # Wait for convergence
    log "Waiting for network convergence..."
    sleep 30
    
    # Verify deployment
    log "Verifying deployment..."
    
    export -f verify_device warning
    echo $SPINES $LEAVES | tr ' ' '\n' | parallel -j $PARALLEL_JOBS verify_device {}
    
    log "Deployment completed successfully!"
    log "Check $LOG_DIR for configuration files and logs"
}

# Run main function
main "$@"
